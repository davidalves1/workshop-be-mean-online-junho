{"name":"Workshop-be-mean-online-junho","tagline":"Arquivos do Workshop Be MEAN de Junho","body":"#Be MEAN - Criando sistemas inteiros apenas com Javascript\r\nVamos aprender com esse material a criar um sistema inteiro utilizando apenas nosso querido e amado Javascript. Desde o Frontend até o Banco de Dados. \r\n\r\n![](https://i.cloudup.com/WI6pC8JKia.png) \r\n\r\n##MEAN\r\n![](https://i.cloudup.com/Taslszh86K.jpg)\r\n\r\n###O que siginifica MEAN?\r\nNada mais que a sigla das tecnologias utilizadas:\r\n- MongoDb\r\n- Express\r\n- AngularJs\r\n- Node.js\r\n\r\n##Por que usar MEAN?\r\nHoje essa stack MEAN nos oferece as mesmas funcionalidades que stacks largamente utilizadas como LAMP/MAMP/WAMP adicionando maior performance opr utilizar tecnologias feitas para escalar como Node.js e MongoDb.\r\n\r\nSem contar que o Javascript é a linguagem mais utilizada na Web não precisando muito esforço para entender o porquê já que é a única linguagem que roda nativamente em qualquer navegador e que foi criada especificamente para a Internet, por mais que ainda precise melhorar muito, mas já está no caminho com o EcmaScript 6.\r\n\r\n##Arquitetura\r\nNesse Workshop iremos criar um Single Page App onde nosso Frontend feito com AngularJs consumirá os dados do Backend feito com o Node.js e MongoDb.\r\n![](https://i.cloudup.com/bg9bVWvHGG.png)\r\n\r\n##MongoDb\r\n###NoSQL\r\nO termo NoSQL foi usado pela primeira vez em 1998 como o nome de um banco de dados relacional de código aberto que não possuía um interface SQL. Seu autor, Carlo Strozzi, alega que o movimento NoSQL \"é completamente distinto do modelo relacional e portanto deveria ser mais apropriadamente chamado \"NoREL\" ou algo que produzisse o mesmo efeito\". Porém o termo só voltou a ser assunto em 2009 por um funcionário do Rackspace, Eric Evans, quando Johan Oskarsson da Last.fm queria organizar um evento para discutir bancos de dados open source distribuídos. \r\n\r\nNoSQL são diferentes sistemas de armazenamento que vieram para suprir necessidades onde os bancos de dados tradicionais(Relacionais) são ineficazes. Muitas dessas bases apresentam características muito interessantes como alta performance, escalabilidade, replicação, suporte à dados estruturados, grafos e sub-colunas. \r\n\r\nO NoSQL surgiu da necessidade de uma performance superior e de alta escalabilidade. Os atuais bancos de dados relacionais são muito restritos a isso, sendo necessário a distribuição vertical de servidores, ou seja, quanto mais dados, mais memória e mais disco um servidor precisa. O NoSQL tem uma grande facilidade na distribuição horizontal, ou seja, mais dados, mais servidores, não necessariamente de alta performance. Um grande utilizador desse conceito é o google, que usa computadores de pequeno e médio porte, para a distribuição dos dados, essa forma de utilização e muito mais eficiente e econômica. Alem disso, os bancos de dados NoSQL são muito tolerantes a erros. \r\n\r\nNo caso dos bancos NoSQL toda a a informação necessária estará agrupada no mesmo registro, ou seja, em vez de você ter o relacionamento entre várias tabelas para formar uma informação ela estará em sua totalidade no mesmo registro. \r\n\r\n####Por que usar?\r\nOs bancos de dados NoSQL nasceram de necessidades mais específicas, então quase sempre encontramos algum para resolver melhor algum problema. Caso necessitemos de um sistema que tenha como obrigação alta escalabilidade a baixo custo provavelmente usaremos algum banco de dados NoSQL.   \r\nQuando nosso banco de dados relacional não aguenta mais requisições crescentes e o servidor ja está no seu máximo essa seria uma boa hora para testar algum NoSQL. Assim como podemos usar mais de um banco NoSQL para tratar de objetivos específicos. \r\nAlém disso vários bancos NoSQL são schema-less, ou seja, não necessitam que uma estrutura seja pré-definida para a inserção de dados. Isso proporciona maior dinamismo na manipulação dos dados.\r\n\r\n####Onde usar?\r\nHoje em dia temos vários bancos NoSQL que podem resolver diversos problemas porém eles não são a chave para TODOS os problemas. Ainda existem cenários onde os bancos relacionais são mais indicados, visto que os mesmos possuem propriedades ACID, logo são melhores em cenários onde os dados são muitíssimo importantes e não pode haver nenhuma quebra de referencia. Ou seja não indicaria, ainda, algum banco NoSQL para sistemas de transações financeiras, por exemplo.\r\nAgora se o seu sistema é alguma rede social, ou algum site que necessite de alta disponibilidade ou escalabilidade com certeza lhe indicaria algum banco NoSQL.\r\nEntretanto não precisamos mudar todo o sistema para algum banco NoSQL, podemos muito bem utilizar um banco NoSQL e um relacional em conjunto. Como muitos ja fazem hoje em dia mas nem percebem. Por exemplo um sistema que utiliza cache, com certeza esta usando um banco NoSQL no cache como o mais conhecido Memcached. A Api Storage do HTML5 também utiliza um sistema de banco NoSQL do tipo chave-valor.\r\n\r\n####Tipo de armazenamento\r\nExistem diversos tipos de armazenamento, onde cada um trata os dados de uma forma diferente e que pode ser mais específico para o objetivo desejado.\r\nOs tipo de armazenamento são: Wide Column Store/Column Families, Document Store, Key Value/Tuple Store, Eventually Consistent Key Value Store, Graph Databases, Object Databases, Grid Database Solutions, XML Databases. Lista retirada de http://nosql-database.org/ \r\n\r\n#####Key/Value Store\r\nEsse é o tipo de banco de dados NoSQL mais simples o conceito dele é uma chave e um valor para essa chave, mas ele é o que aguenta mais carga de dados. Esses tipos de bancos de dados, são o que tem a maior escalabilidade. \r\n- Berkeley DB \r\n- Tokyo Cabinet \r\n- Kyoto Cabinet\r\n- Project Voldermort \r\n- MemcacheDB \r\n- SimpleBD \r\n- Redis\r\n- Riak\r\n\r\n#####Wide Columns Store\r\nFortemente inspirados pelo BigTable do Google eles suportam várias linhas e colunas, alem disso ele permite subcolunas. Alem do BigTable do google outros que usam essa tecnologia são: \r\n- HBase(Apache) \r\n- HiperTable \r\n- Cassandra(Apache) \r\n\r\n#####Document Store\r\nBaseado em documentos XML ou JSON, podem ser localizados pelo seu id unico ou por qualquer registro que tenha no documento. \r\n- CouchDB(Apache) \r\n- MongoDB \r\n- RavenDB \r\n\r\n#####Graph Store\r\nCom uma complexibilidade maior esses bancos de dados guardam objetos e não registros como os outros tipos de NoSQL. A busca destes itens são feitas pela navegação destes objetos. \r\n- Neo4J \r\n- InfoGrid \r\n- HyperGraphDB \r\n\r\nNa imagem abaixo podemos ver um gráfico demonstrando a diferença entre o tamanho da base de dados pela complexidade dos seus dados. Assim podemos perceber que os bancos do tipo chave-valor conseguem aguentar mais dados, sendo que seus dados são mais simples, enquanto que os banco do tipo grafo aguentam menos dados porém seus dados são mais complexos.\r\n\r\n![](http://blog.3pillarglobal.com/sites/default/files/nosql-3a.png)\r\n\r\n###Introdução\r\nO MongoDB é um dos bancos NoSQL mais utilizados atualmente pela sua facilidade de instalação, documentação e os diversos drivers para inúmeras linguagens de programação. Ele é um banco de dados orientado a documentos, escalável, livre de esquema, de alto desempenho e código aberto escrito em C++.\r\nAlgumas funcionalidades interessantes do MongoDB são: orientação a documentos(JSON/BSON), suporte a index, replicação e alta disponibilidade, auto-sharding, map/reduce GridFS e suporte comercial da 10gen.\r\n\r\n####Schemaless\r\n![](http://www.greenberg-art.com/.Illustrations/.Humorous/qq1sgMessyDesk.jpg)\r\nO que significa ser livre de esquema? Basicamente é não precisar ter nenhum objeto identificando como será nosso modelo de persistência, ou seja, não terá nada dizendo o nome dos campos nem seus tipos.\r\n\r\nE isso é bom? Dependendo do que você quer fazer sim, ele dá maior liberdade para futuras modificações e maiores possibilidades de modelagem em comparação à relacional.\r\n\r\n####JSON/BSON\r\n![](http://wp.clicrbs.com.br/infosfera/files/2014/04/jason-2.jpg)\r\nO MongoDb é um banco NoSQL orientado a documento [JSON](http://json.org/), ou seja, ele persiste os dados usando o formato [JSON](http://json.org/) criando assim um formato único de troca de dados em todo stack [MEAN](http://bemean.com.br/).\r\n\r\n####Replica\r\n![](http://images.freshnessmag.com/wp-content/uploads/2010/07/bat-pod-replica-1.jpg)\r\nPossuímos réplicas na maioria dos bancos de dados relacionais também, ela apenas faz o espelhamento dos seus dados de um servidor para outro.\r\n\r\n####Sharding\r\n![](http://www.codefutures.com/img/dbshards-shardit.gif)\r\n\r\n####GridFs\r\n![](http://www.kratedesign.com/wp-content/uploads/2012/11/less-files-more-miles.jpg)\r\n\r\n##Express\r\n![](https://i.cloudup.com/OgEsvIwmiL.png)\r\n\r\nIremos trabalhar com uma API REST no Express e para isso iremos utilizar 4 verbos diferentes para trabalhar com nossas rotas e para isso faremos um CRUD:\r\n\r\n- Create: POST\r\n- Retrieve: GET\r\n- Update: PUT\r\n- Delete: DELETE\r\n\r\nPara iniciarmos qualquer funcionalidade vamos pensar \r\nno seguinte workflow:\r\n\r\n1 cria uma rota no módulo. Ex.: /routes/beers\r\n\r\n    // Rota para consulta da cerveja   \r\n    router.get('/show', beer.show);\r\n\r\n2 Criar a view a ser renderizada\r\n\r\n    p.show\r\n      span\r\n        | Name: #{cerveja.name}\r\n      span\r\n        | Price: #{cerveja.price}\r\n      span\r\n        | Alcohol: #{cerveja.alcohol}\r\n      span\r\n        | Description: #{cerveja.description}\r\n\r\n3 cria uma função no controller. Ex.: /controllers/beer\r\n\r\n    function(req, res){\r\n    // Primeiramente precisamos consultar ae cerveja\r\n    var query = {_id: req.params.id};\r\n    Beer.findOne(query, function (err, data) {\r\n      if (err){\r\n        console.log('Erro: ', err);\r\n        msg = 'Erro ao listar as cervejas!';\r\n        res.render('beer/show', \r\n          {\r\n            title: 'Adega Be MEAN',\r\n            msg: msg\r\n          }\r\n        );\r\n      }else{\r\n        console.log('Listagem: ', data);  \r\n        msg = 'Cerveja: ' + data.name; \r\n        // Enviamos a cerveja para view\r\n        res.render('beer/show', \r\n          {\r\n            title: 'Adega Be MEAN', \r\n            cerveja: data,\r\n            msg: msg\r\n          }\r\n        );\r\n      }\r\n    });\r\n\r\nCom o show funcionando podemos refatorar nossa view `beer/index.jade` para:\r\n\r\n    ul\r\n      for cerveja in cervejas\r\n        li\r\n          a(href='/beers/show/#{cerveja._id}')\r\n            | #{cerveja.name} - #{cerveja.category}\r\n\r\nPara iniciarmos a função de update, precisamos criar a rota da renderização\r\nda sua view, /routes/beers.js\r\n\r\n// Rota para alteração da cerveja\r\nrouter.get('/save/:id', beer.save);\r\n\r\nDepois criamos nossa função no controller\r\n\r\n    function(req, res){\r\n      // criando o objeto de query\r\n      // para fazer a busca da cerveja a ser alterada\r\n      var query = {_id: req.params.id};\r\n\r\n      // crio o objeto de modificação da cerveja\r\n      // recebendo os dados via req.body\r\n      var mod = req.body;\r\n\r\n      Beer.update(query, mod, function (err, data) {\r\n        if (err){\r\n          console.log('Erro: ', err);\r\n          msg = 'Erro ao atualizar a cerveja!';\r\n          // Enviamos a msg para view\r\n          res.render('beer/show', \r\n            {\r\n              title: 'Adega Be MEAN', \r\n              cerveja: data,\r\n              msg: msg\r\n            }\r\n          );\r\n        }else{\r\n          console.log('Cerveja atualizada com sucesso', data);\r\n          msg = 'Cerveja atualizada com sucesso!';    \r\n          // Enviamos a cerveja para view\r\n          res.render('beer/show', \r\n            {\r\n              title: 'Adega Be MEAN', \r\n              cerveja: data,\r\n              msg: msg\r\n            }\r\n          );\r\n        } \r\n      });\r\n\r\nDepois disso precisamos criar nossa view. Como não possuímos o verbo PUT via\r\nHTML, precisamos emular ele. No caso utilizaremos um input[type=hidden] \r\npara enviar o nome do verbo, podendo ser: PUT ou DELETE, via POST. E \r\nenviamos o name do input como `_method._ \r\nFicando assim:\r\n\r\n    form(action='/api/beers', method='POST')\r\n      label\r\n        | Name:\r\n        input(type='text', name='name', value='#{cerveja.name}')\r\n      label\r\n        | Price:\r\n        input(type='text', name='price', value='#{cerveja.price}')\r\n      label\r\n        | Alcohol:\r\n        input(type='text', name='alcohol', value='#{cerveja.alcohol}')\r\n      label\r\n        | Description:\r\n        textarea(name='description')\r\n          | #{cerveja.description}\r\n      input(type='hidden', name='_method', value='PUT')\r\n      input(type='submit', value='SALVAR')\r\n\r\nSendo que um middleware no Express fará a conversão de POST para PUT.\r\nO middleware utilizado é o methodOverride.\r\n\r\nNão esquecer de instalar localmente:\r\n        npm install --save method-override\r\n\r\n\r\nPara usarmos o method override com o nosso input, precisamos chamá-lo:\r\n\r\n    app.use(\r\n        methodOverride(function(req, res){\r\n          if (req.body && typeof req.body === 'object' && '_method' in req.body) {\r\n            // look in urlencoded POST bodies and delete it\r\n            var method = req.body._method;\r\n            delete req.body._method;\r\n            return method;\r\n          }\r\n        })\r\n    );\r\n\r\n\r\nApós criarmos o UPDATE, vamos criar o DELETE. Criando inicialmente a \r\nnossa rota em routes/beers.js:\r\n\r\n    // Rota para remoção da cerveja\r\n    router.get('/remove/:id', beer.remove);\r\n\r\nDepois criamos a função no controller que essencialmente é igual ao show:\r\n\r\n    function(req, res){\r\n        // criando o objeto de query\r\n        // para fazer a busca da cerveja a ser alterada\r\n        var query = {_id: req.params.id};\r\n\r\n        Beer.findOne(query, function (err, data) {\r\n          if (err){\r\n            console.log('Erro: ', err);\r\n            msg = 'Erro ao buscar a cerveja!';\r\n            // Enviamos a msg para view\r\n            res.render('beer/remove', \r\n              {\r\n                title: 'Adega Be MEAN', \r\n                cerveja: data,\r\n                msg: msg\r\n              }\r\n            );\r\n          }else{\r\n            console.log('Cerveja removida com sucesso', data);\r\n            msg = 'Cerveja: ' + data.name; \r\n            // Enviamos a cerveja para view\r\n            res.render('beer/remove', \r\n              {\r\n                title: 'Adega Be MEAN', \r\n                cerveja: data,\r\n                msg: msg\r\n              }\r\n            );\r\n          } \r\n        });\r\n\r\nAgora criamos nossa view que também é parecida com o a save.jade:\r\n\r\n      form(action='/api/beers/#{cerveja._id}', method='POST', enctype='application/x-www-form-urlencoded')\r\n        label\r\n          | Name:\r\n          input(type='text', name='name', value='#{cerveja.name}')\r\n        label\r\n          | Category:\r\n          input(type='text', name='category', value='#{cerveja.category}')\r\n        label\r\n          | Price:\r\n          input(type='text', name='price', value='#{cerveja.price}')\r\n        label\r\n          | Alcohol:\r\n          input(type='text', name='alcohol', value='#{cerveja.alcohol}')\r\n        label\r\n          | Description:\r\n          textarea(name='description')\r\n            | #{cerveja.description}\r\n        input(type='hidden', name='_method', value='DELETE')\r\n        input(type='submit', value='REMOVER')\r\n\r\n\r\n\r\n\r\n#AngularJs\r\n!()[https://i.cloudup.com/_O1Y7F0CfP.png]\r\n\r\nO AngularJS é um framework criado por Misko Hevery e mantido pelo Google.\r\nEle trabalha com uma estrutura de MVC e um ótimo sistema de two way\r\ndata-bindings, além de suas diretivas darem super-poderes ao HTML.\r\n\r\nComo o AngularJs é um framework e não uma biblioteca como o jQuery, o modo\r\nde se trabalhar com ele é um pouco diferente do que éramos acostumados.\r\n\r\nPara iniciarmos uma aplicação com o AngularJs, precisamos adicionar\r\no atributo ng-app em alguma tag do nosso HTML, normalmente em body ou html.\r\n\r\n**dica**\r\nVamos instalar um servidor web em Node.js para que possamos rodar nossos\r\narquivos com AngularJs:\r\n\r\n    npm install -g http-server\r\n\r\nE para rodarmos, basta ir na pasta onde estão nosso arquivos e rodar:\r\n\r\n    http-server\r\n    Starting up http-server, serving ./ on port: 8080\r\n    Hit CTRL-C to stop the server\r\n\r\n**dica**\r\n\r\nEntão nosso exercício 01 ficará:\r\n\r\n    <!doctype html>\r\n    <html lang=\"en\">\r\n    <head>\r\n      <meta charset=\"UTF-8\">\r\n      <title>Workshop Be MEAN</title>\r\n    </head>\r\n    <!-- Iniciando minha aplicação com ng-app -->\r\n    <body ng-app>\r\n      \r\n      <!-- Parseando essa expressão -->\r\n        {{ 2 + 2}}\r\n        <script src=\"angular.min.js\"></script>\r\n    </body>\r\n    </html>\r\n\r\nEntão basta entrarmos em http://localhost:8080/ex01.html\r\n\r\nNosso template engine só executa as expressões que estão entre {{ }}.\r\n\r\nAgora vamos salvar como esse exercício como ex02 e vamos modificar para\r\nque fique dessa forma:\r\n\r\n    <!doctype html>\r\n    <html>\r\n      <body data-ng-app=\"workshopBeMEAN\">\r\n\r\n        Olá mundo, 2 + 2 = {{ 2 + 2}}\r\n\r\n        <script src=\"angular.min.js\"></script>\r\n        <script>\r\n          angular.module('workshopBeMEAN', []);\r\n        </script>\r\n      </body>\r\n    </html>\r\n\r\nDessa forma estamos setando um nome para nosso app `data-ng-app=\"workshopBeMEAN\"` e você deve ter percebido o data- antes, dessa forma\r\nseu código ficará válido para HTML5, mas não faz diferença real.\r\n\r\nDepois no nosso script nós realmente criamos nosso módulo da aplicação:\r\n\r\n    <script>\r\n      angular.module('workshopBeMEAN', []);\r\n    </script>\r\n\r\nEstamos passando um array vazio, [], pois ainda não temos dependências\r\na serem injetadas no nosso módulo. Pois a base do AngularJs é a injeção\r\nde dependências.\r\n\r\nPara exemplificar um uso muito simples da injeção de dependência, imagine\r\nque você possui um CRUD e está usando dessa forma:\r\n\r\n    function create(){\r\n        var db = mongoose.connection();\r\n        // já temos o models e os dados e vamos salvar\r\n        return user.save();\r\n    };\r\n    function retrieve(){\r\n        var db = mongoose.connection();\r\n        return user.list();\r\n    };\r\n    function update(dados){\r\n        var db = mongoose.connection();\r\n        return user.update(dados);\r\n    };\r\n    function delete(){\r\n        var db = mongoose.connection();\r\n        return user.remove();\r\n    };\r\n\r\nE agora seu sistema vai mudar de MongoDb para CouchDb, o que fazer?\r\nSe o seu código estiver sem injeção de dependência você precisará modificar\r\ntodo seu código, por exemplo:\r\n\r\n    function create(){\r\n        var db = couchDb.connection();\r\n        // já temos o models e os dados e vamos salvar\r\n        return user.save();\r\n    };\r\n    function retrieve(){\r\n        var db = couchDb.connection();\r\n        return user.list();\r\n    };\r\n    function update(dados){\r\n        var db = couchDb.connection();\r\n        return user.update(dados);\r\n    };\r\n    function delete(){\r\n        var db = couchDb.connection();\r\n        return user.remove();\r\n    };\r\n\r\nAgora caso você tivesse escrito o código já com injeção de dependência, \r\nele ficaria assim:\r\n\r\n    // var db = mongoose.connection();\r\n    var db = couchDb.connection();\r\n    function create(db){\r\n        // já temos o models e os dados e vamos salvar\r\n        return user.save();\r\n    };\r\n    function retrieve(db){\r\n        return user.list();\r\n    };\r\n    function update(db, dados){\r\n        return user.update(dados);\r\n    };\r\n    function delete(db){\r\n        return user.remove();\r\n    };\r\n\r\nCom isso eu crio a dependência externamente, independente do código de cada\r\nfunção, ficando assim mais simples de se trocar as peças injetadas.\r\n\r\n###Two-way data binding\r\n!()[https://i.cloudup.com/ydNx3qYuyu.png]\r\n\r\nO two-way data binding é uma forma onde a view é gerada pelo template, porém\r\nsem o merge com o Model, deixando com que os dados possam ser atualizados\r\na partir do Model e vice-versa. Logo qualquer modificação no Model irá \r\natualizar a View e qualquer modificação na View irá atualizar o Model.\r\n\r\nExemplo:\r\n\r\n    <label>Seu nome: \r\n      <input type=\"text\" data-ng-model=\"nome\"> \r\n    </label>\r\n    <p>\r\n      Olá mundo, {{ nome }}\r\n    </p>\r\n\r\n\r\nCom isso quando escrevemos qualquer coisa no input ele automaticamente \r\natualiza o texto \"Olá mundo, \" com esse valor. \r\n\r\nApenas para dar um exemplo de como isso ficaria com jQuery:\r\n\r\n    $(document).ready(function(){\r\n      $('input[type=text]').on('input', function(){\r\n        var val = $(this).val();\r\n        $('p').text(val);\r\n      });\r\n    });\r\n\r\n\r\nAgora salve como ex04 e modifique o TITLE:\r\n\r\n    <title>{{ workshop }}</title>\r\n\r\nDepois adicione no BODY um ng-model:\r\n\r\n    <label>Workshop: \r\n      <input type=\"text\" data-ng-model=\"workshop\"> \r\n    </label>\r\n\r\nCom isso nós iremos pdoer modificar nosso TITLE dinamicamente. Porém antes \r\npreciso colocar meu ng-app acima do TITLE, ficando:\r\n\r\n    <html data-ng-app=\"workshopBeMEAN\">\r\n\r\n###Filters\r\n!()[https://i.cloudup.com/830l3-ls6B.png]\r\nOs filtros serverm para transformar e formatar dados já exibidos para \r\no usuário. Para isso precisamos apenas criar seu módulo, sua função e \r\ninjetar como dependência na nossa aplicação.\r\n\r\nPara chamar um filtro precisamos passa apenas ` | nomeFiltro`\r\n\r\n    <h3>Olá mundo, {{ nome | reverseName }}</h3>\r\n\r\nCriando o módulo para o filtro e injetando na nossa aplicação:\r\n\r\n    <script>\r\n      angular.module('workshopBeMEAN', ['workshopFilters']);\r\n      angular.module('workshopFilters', [])\r\n      .filter('reverseName', function () {\r\n        return function (text) {\r\n          if(text)\r\n            return text.split(\"\").reverse().join(\"\");\r\n        };\r\n      });\r\n    </script>\r\n\r\nTambém podemos utilizar mais de um filtro, apenas adicionando \r\n` | nomeFiltro`\r\n\r\n\r\n    <h3>Olá mundo, {{ nome | reverseName | uppercase }}</h3>\r\n\r\nPossuímos diversos filtros nativos no AngularJs como:\r\n\r\n- uppercase: {{ nome | uppercase }}\r\n- lowercase: {{ nome | lowercase }}\r\n- number: {{ 1234 | number:2 }}\r\n- date: {{ 1402772567464 | date:'dd/MM/yyyy HH:mm:ss Z'}}\r\n- currency: {{ amount | currency:\"R$\" }}\r\n\r\n\r\n###Controllers\r\n\r\nPara criarmos um controller precisamos apenas adicionar ele em um módulo, \r\ncomo no exemplo a seguir:\r\n\r\n    angular.module('workshopBeMEAN', ['filters'])\r\n      .controller('BeerController', ['$scope', function($scope){\r\n        $scope.reverse = false;\r\n        var cervejas = [{\r\n          name: 'Kaiser', price: 2\r\n          }, {\r\n            name: 'Skol', price: 3\r\n          }, {\r\n            name: 'Glacial', price: 4\r\n          }, {\r\n            name: 'Polar', price: 6\r\n          }, {\r\n            name: 'Heineken', price: 10\r\n          }\r\n        ];\r\n        $scope.cervejas = cervejas;\r\n      }]);\r\n\r\nEm cada controllers nós precisaremos injetar suas dependências, principalmente \r\no $scope que é o nosso Model.\r\n\r\n    ['$scope', function($scope)\r\n\r\nEu poderia muito bem passar como dependência apenas via paramêtro:\r\n\r\n    function($scope)\r\n\r\nPorém quando eu for minificar meu arquivo isso poderá gerar problemas, pois \r\ntodos os outros controllers também possuem seus scopes. Logo a melhor forma \r\ne a mais indicada para injetar as dependências é listá-las antes como string.\r\n\r\nPara que eu consiga acessar dados da minha View, preciso adicionar os valores \r\nno $scope:\r\n\r\n    var cervejas = [{\r\n      name: 'Kaiser', price: 2\r\n      }, {\r\n        name: 'Skol', price: 3\r\n      }, {\r\n        name: 'Glacial', price: 4\r\n      }, {\r\n        name: 'Polar', price: 6\r\n      }, {\r\n        name: 'Heineken', price: 10\r\n      }\r\n    ];\r\n    $scope.cervejas = cervejas;\r\n\r\nCom isso eu tenho acesso na minha View com {{ cervejas }}\r\n\r\nEntão com nosso array acessível na View podemos iterar sobre ele utilizando \r\na diretiva ng-repeat:\r\n    \r\n    <ul>\r\n      <li data-ng-repeat='beer in cervejas | orderBy:predicate:reverse'>\r\n        {{ beer.name }} - {{ beer.price }}\r\n      </li>\r\n    </ul>\r\n\r\nNesse código o `ng-repeat` irá criar uma linha com `<li>` para cada cerveja \r\nque exista no nosso array. Muito parecido com o nosso for feito no Jade, porém estamos utilizando um dos filtros mais poderosos que é o orderBy:\r\n\r\n    | orderBy:predicate:reverse'\r\n\r\nEntão esse filtro me diz que preciso ordenar pelo predicate seguindo reverse.\r\n\r\n    <a href=\"\" data-ng-click=\"predicate = 'name'; reverse=!reverse\">Nome</a>\r\n\r\nComo podemos ver nesse link, possuímos a diretiva `ng-click` a qual irá \r\nsetar predicate='name' e reverse=!reverse, ou seja, inverte o valor de reverse.\r\nQuando eu clickar nesse link ele irá setar esses valores fazendo com que o \r\nAngularJs ordene automaticamente nosso array.\r\n\r\nPara tirarmos proveito da modularização do AngularJs iremos criar um módulo \r\npara nosso controller, como no ex09:\r\n\r\n    angular.module('workshopBeMEAN', ['workshopFilters', 'workshopControllers']);\r\n      angular.module('workshopControllers', [])\r\n      .controller('BeerController', ['$scope', \r\n        function($scope){\r\n          var cerveja1 = {name: 'kaiser', price: 2};\r\n          var cerveja2 = {name: 'skol', price: 3};\r\n          var cerveja3 = {name: 'glacial', price: 4};\r\n          var cerveja4 = {name: 'polar', price: 6};\r\n          // ADICIONANDO AS CERVEJAS NO SCOPE DO CONTROLLER\r\n          $scope.cervejas = [cerveja1, cerveja2, cerveja3, cerveja4];\r\n      }]);\r\n\r\n\r\nAgora vamos ver com utilizamos 2 Controllers na mesma view, para que isso \r\nseja possível precisamos utilizar a diretiva `ng-controller`.\r\n\r\n    <div data-ng-controller='BeerController'>\r\n    <div data-ng-controller='EnderecoController'>\r\n\r\nDeixando nosso módulo de Controllers da seguinte forma:\r\n\r\n    angular.module('workshopControllers', [])\r\n      .controller('EnderecoController', ['$scope', '$http', \r\n        function($scope, $http){\r\n\r\n          // exemplo de função que irá rodar com um CLICK\r\n          $scope.rodar = function(){\r\n            alert('RODOU');\r\n          }\r\n\r\n          var url = 'http://cors.io/cep.correiocontrol.com.br/02011200.json';\r\n\r\n          $http.get(url)\r\n          .success(function(data) { //função executada após o sucesso da requisição\r\n            console.log(data);\r\n            $scope.end = data;\r\n            // Object {bairro: \"Santana\", logradouro: \"Rua Voluntários da Pátria\", cep: \"02011200\", uf: \"SP\", localidade: \"São Paulo\"} \r\n          })\r\n          .error(function(err){ //função executada após o erro da requisição\r\n            console.log('Error: ', err)\r\n          });\r\n        }])\r\n      .controller('BeerController', ['$scope', '$http',\r\n        function($scope, $http){\r\n          var cerveja1 = {name: 'kaiser', price: 2};\r\n          var cerveja2 = {name: 'skol', price: 3};\r\n          var cerveja3 = {name: 'glacial', price: 4};\r\n          var cerveja4 = {name: 'polar', price: 6};\r\n          // ADICIONANDO AS CERVEJAS NO SCOPE DO CONTROLLER\r\n          $scope.cervejas = [cerveja1, cerveja2, cerveja3, cerveja4];\r\n      }]);\r\n\r\nEntão para usarmos nosso $http, antes precisamos injetá-lo como dependência:\r\n\r\n    ['$scope', '$http', function($scope, $http)\r\n\r\nDepois já podemos utilizá-lo da seguinte forma:\r\n\r\n\r\n    var url = 'http://cors.io/cep.correiocontrol.com.br/02011200.json';\r\n\r\n    $http.get(url)\r\n    .success(function(data) { //função executada após o sucesso da requisição\r\n      console.log(data);\r\n      $scope.end = data;\r\n      // Object {bairro: \"Santana\", logradouro: \"Rua Voluntários da Pátria\", cep: \"02011200\", uf: \"SP\", localidade: \"São Paulo\"} \r\n    })\r\n    .error(function(err){ //função executada após o erro da requisição\r\n      console.log('Error: ', err)\r\n    });\r\n\r\n**dica**\r\nEstou usando o serviço do `cors.io` para fazer requisições externas, já que \r\nos navegadores implementam a política de mesma origem \r\n([Same-origin Policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)), ou seja, você só pode \r\nfazer requisições via navegador para o mesmo servidor, não podendo mudar \r\nnenhuma dessas 3 variáveis:\r\n\r\n- protocolo\r\n- host\r\n- porta\r\n\r\n    protocolo://host:porta\r\n    http://localhost:8080 é diferente de:\r\n    https://localhost:8080 \r\n    http://sub.localhost:8080 \r\n    http://localhost:3000\r\n\r\nEntão para \"burlar\" essa política nosso servidor precisa habilitar o \r\n[CORS](http://pt.wikipedia.org/wiki/Cross-origin_resource_sharing), \r\ncaso não tenhamos acesso ao servidor, podemos utilizar esse serviço web \r\nrodando em `http://cors.io`.\r\n\r\nNo retorno da nossa consulta com $http recebemos 2 promisses:\r\n\r\n- success\r\n- error\r\n\r\nEntão é nessas promisses que minha lógica de manipulação do retorno irá \r\ntrabalhar.\r\n\r\n    .success(function(data) { //função executada após o sucesso da requisição\r\n      console.log(data);\r\n      $scope.end = data;\r\n      // Object {bairro: \"Santana\", logradouro: \"Rua Voluntários da Pátria\", cep: \"02011200\", uf: \"SP\", localidade: \"São Paulo\"} \r\n    })\r\n    .error(function(err){ //função executada após o erro da requisição\r\n      console.log('Error: ', err)\r\n    });\r\n\r\nEntão fica claro de identificar o que cada uma faz e com isso deixamos \r\nnosso código mais limpo e legível.\r\n\r\nNa promisse de success é onde instanciamos a variável end no nosso $scope\r\n\r\n    $scope.end = data;\r\n\r\nPara que ela seja acessível dentro do nosso Controller na View.\r\n\r\n    <div data-ng-controller='EnderecoController'>\r\n      <button data-ng-click='rodar()'>Click aqui</button>\r\n      <p>\r\n        Endereço: {{ end }}\r\n      </p>\r\n    </div>\r\n\r\nOu seja, eu só acesso as variáveis e funções do meu $scope dentro do meu \r\nng-controller correto. Pois esses dados só existem nesse $scope local.\r\n\r\nAlém de usarmos o $http nesse Controller também criamos uma função que será \r\nacessada via `ng-click`:\r\n\r\n    // exemplo de função que irá rodar com um CLICK\r\n      $scope.rodar = function(){\r\n        alert('RODOU');\r\n      }\r\n\r\nEla será chamada na nossa view da seguinte forma:\r\n\r\n    <button data-ng-click='rodar()'>Click aqui</button>\r\n\r\n###Rotas\r\n![](https://i.cloudup.com/M_kYIOWyyn.png)\r\n\r\nVamos iniciar esse módulo clonando o seed do AngularJs.\r\n\r\n    git clone git://github.com/angular/angular-seed.git\r\n\r\nDepois de entrar na pasta angular-seed, você verá o arquivo `bower.json`.\r\nPara instalarmos nossos assets de frontend, precisamos instalar o Bower antes.\r\n\r\n    npm install -g bower\r\n\r\nAgora localmente primeiro vamos rodar:\r\n\r\n    npm install\r\n\r\nPara iniciar nosso projeto precisamos apenas rodar:\r\n\r\n    npm start\r\n\r\nDepois conferir me `localhost:8000/app`.\r\n\r\nO nosso roteamento se dá apenas no navegador sem que precisemos requisitar \r\nnenhum dado no nosso servidor. Já que o AngularJs é um framework para \r\nSingle Page Applications ele irá gerenciar todas essas rotas localmente, \r\nemulando a troca das URL utilizando a History API e PushState.\r\n\r\nPara definirmos nossas rotas iremos utilizar o `$routeProvider`.\r\n\r\n    config(['$routeProvider', function($routeProvider) {\r\n      $routeProvider.when('/view1', {templateUrl: 'partials/partial1.html', controller: 'MyCtrl1'});\r\n      $routeProvider.when('/view2', {templateUrl: 'partials/partial2.html', controller: 'MyCtrl2'});\r\n      $routeProvider.otherwise({redirectTo: '/view1'});\r\n    }])\r\n\r\nOnde em `when` eu irei setar minha rota, passando sua url e um objeto com \r\nmeu Template, `templateUrl`, e meu Controller, `controller`.\r\n\r\n####templateUrl\r\nO templateUrl é a URL para a nossa View a ser renderizada.\r\n\r\n####controller\r\nO controller irá chamar a função setada nele.\r\n\r\n####otherwise\r\nÉ a função parecida com o default do switch, ou seja, caso a rota \r\nrequisitada não exista ele irá redireciar para essa.\r\n\r\nApós criarmos nossa rota em config, precisamos criar nossa view em\r\n`partials/beers/index.html`\r\n\r\n    <h3>\r\n      {{ workshop }}\r\n    </h3>\r\n\r\n    INDEX DAS CERVEJAS\r\n\r\nDepois vamos criar nosso controller `BeersIndexCtrl`:\r\n\r\n    .controller('BeersIndexCtrl', ['$scope', function ($scope) {\r\n      $scope.workshop = 'Workshop Be MEAN';\r\n    }])\r\n\r\nPassando apenas a variável workshop para ser mostrada na View.\r\n\r\nNo `app/index.html` a linha mais importante para renderizar as views é \r\na seguinte:\r\n\r\n    <div ng-view></div>\r\n\r\nPois o `ng-view` é o responsável por renderizar as views.\r\n\r\n\r\n###RETRIEVE\r\nAgora vamos criar a View list.html e modificar na nossa rota.\r\n\r\n    $routeProvider.when('/beers', {\r\n        templateUrl: 'partials/beers/list.html', \r\n        controller: 'BeersIndexCtrl'\r\n      });\r\n\r\nCopiando o código do nosso exercício 08 nossa View lista ficará:\r\n\r\n    <h3>\r\n      {{ workshop }}\r\n    </h3>\r\n      \r\n    <!-- Usando o filtro de ordenação -->\r\n    <a href=\"\" data-ng-click=\"reverse=!reverse\">\r\n      Ordenar por {{ predicate }} - {{ !reverse }}\r\n    </a>\r\n        \r\n    <!-- Vamos listar nosso array usando o ng-repeat -->\r\n    <ul>\r\n    <!-- Parecido com o nosso for no Jade -->\r\n      <li data-ng-repeat='beer in cervejas | orderBy:predicate:reverse'>\r\n      <!-- acessando os valores do array -->\r\n        {{ beer.name }} - {{ beer.price }}\r\n      </li>\r\n    </ul>\r\n\r\nCopiamos o código do controller também ficando assim:\r\n\r\n    controller('BeersIndexCtrl', ['$scope', function ($scope) {\r\n      $scope.workshop = 'Workshop Be MEAN';\r\n      \r\n      // Código colado do exercicio 08\r\n      $scope.reverse = false;\r\n      $scope.predicate = 'name';\r\n\r\n      // criamos um array de cervejas\r\n      var cervejas = [{\r\n        name: 'Kaiser', price: 2\r\n        }, {\r\n          name: 'Skol', price: 3\r\n        }, {\r\n          name: 'Glacial', price: 4\r\n        }, {\r\n          name: 'Polar', price: 6\r\n        }, {\r\n          name: 'Heineken', price: 10\r\n        }\r\n      ];\r\n\r\n      // instanciamos nosso array no nosso scope\r\n      // para que tenhamos acesso à esse array na View\r\n      $scope.cervejas = cervejas;\r\n      \r\n      }])\r\n\r\nCom isso na nossa rota /beers já temos uma listagem das cervejas com \r\nordenção por nome.\r\n\r\nPara entendermos mais um pouco como as coisas funcionam no AngularJs \r\nvamos pegar nosso exercicio 10 e copiar seu código do $http.\r\n\r\nE vamos substituir essas cervejas setadas na mão por uma consulta na nossa \r\nAPI do Node.js\r\n\r\n    var url = '/api/beers';\r\n    \r\n    $http.get(url)\r\n    .success(function(data){\r\n      $scope.cervejas = data;\r\n      console.log('Cervejas', $scope.cervejas);\r\n    })\r\n    .error(function(err){\r\n      console.log('Error: ', err);\r\n    });\r\n\r\nE corrigimos nossa view `list.jade`:\r\n\r\n    h3\r\n      | {{ workshop }}\r\n    h4 Listagem das cervejas\r\n    table\r\n      thead\r\n        tr\r\n          th \r\n            a.order(data-ng-click='orderBy(\\'name\\')') Name\r\n          th\r\n            a.order(data-ng-click='orderBy(\\'category\\')') Category\r\n      tbody\r\n        tr(data-ng-repeat='cerveja in cervejas | orderBy:predicate:reverse')\r\n          td {{ cerveja.name }}\r\n          td {{ cerveja.category }}\r\n\r\nComo você deve ter percebido estamos chamando a função orderBy, onde ela \r\nirá ordernar nossa tabela a partir dos campos name e categoruy. Então \r\nvamos ver como vai ficar nossa função `orderBy` no controller `BeersIndexCtrl`:\r\n\r\n    $scope.orderBy = function(predicate){\r\n      $scope.predicate = predicate;\r\n      $scope.reverse = !$scope.reverse;\r\n    }\r\n\r\nSetando o `$scope.reverse = !scope.reverse` estamos invertendo a nossa listagem, então quando você clickar novamente no mesmo campo ele apenas inverterá a seleção.\r\n\r\n####Integração com o exercício do Express\r\nAgora vamos integrar a nossa API que criamos no Express anteriormente,  basta seguir esses passos:\r\n\r\n1 - Copiar a pasta controllers do Express para o Angular Express Seed\r\n2 - Copiar a pasta models do Express para o Angular Express Seed\r\n3 - Passar as rotas do Express para o Angular Express Seed\r\n\r\nAs rotas vamos precisar integrar manualmente, então nosso `app.js` do Angular Express Seed ficará assim:\r\n\r\n\r\n    /**\r\n     * Routes\r\n     */\r\n\r\n    // serve index and view partials\r\n    app.get('/', routes.index);\r\n    app.get('/partials/:name', routes.partials);\r\n\r\n    // JSON API\r\n    app.get('/api/name', api.name);\r\n\r\n    // API REST\r\n    // criando o objeto de rotas da API\r\n    var api = {};\r\n    // requisitando nosso controller\r\n    api.beer = require('./controllers/api/beer');\r\n    app.get('/api/beers', api.beer.retrieve);\r\n    app.get('/api/beers/:id', api.beer.findOne);\r\n    app.post('/api/beers', api.beer.create);\r\n    app.put('/api/beers/:id', api.beer.update);\r\n    app.delete('/api/beers/:id', api.beer.delete);\r\n\r\n    // redirect all others to the index (HTML5 history)\r\n    app.get('*', routes.index);\r\n\r\nVocê percebeu que estamos requisitando nossa view do AngularJs para o Node.js?\r\nOlhe nas nossas rotas do AngularJs:\r\n\r\n    when('/view1', {\r\n      templateUrl: 'partials/partial1',\r\n      controller: 'MyCtrl1'\r\n    }).\r\n    when('/view2', {\r\n      templateUrl: 'partials/partial2',\r\n      controller: 'MyCtrl2'\r\n    }).\r\n    // criando a rota de listagem das cervejas\r\n    when('/beers', {\r\n      templateUrl: 'partials/list',\r\n      controller: 'BeersIndexCtrl'\r\n    })\r\n\r\nTodo `templateUrl` bate em `partials/:name` o que é descrito no `app.js` do Express: \r\n\r\n    app.get('/partials/:name', routes.partials);\r\n\r\nEntão vamos ver o que essa função `routes.partials` faz. Primeiramente vemos que ela vem do objeto `routes`:\r\n\r\n    routes = require('./routes'),\r\n\r\nIsso quer dizer que estamos importando o arquivo `routes/index.js`:\r\n\r\n    exports.index = function(req, res){\r\n      res.render('index');\r\n    };\r\n\r\n    exports.partials = function (req, res) {\r\n      var name = req.params.name;\r\n      res.render('partials/' + name);\r\n    };\r\n\r\nCom isso conseguimos entender o que nossa função `partials` faz, ela renderiza qualquer nome de view repassada na URL, exemplo:\r\n\r\n    /routes/list\r\n\r\nVai renderizar:\r\n\r\n    /views/partials/list.jade\r\n\r\nAgora vamos criar nossa própria função de renderização de views genéricas:\r\n\r\n    exports.expose = function(req, res) {\r\n      // pego o diretório da view\r\n      var dir = req.params.dir;\r\n      // pego o nome da view\r\n      var name = req.params.name;\r\n      // crio o nome completo da view\r\n      var view = dir + '/' + name;\r\n\r\n      // renderizo a view\r\n      res.render(view);\r\n    }\r\n\r\nDepois de criamos nossa função `expose` vamos criar a rota que será responsável por executar essa função em app.js do Express:\r\n\r\n    app.get('/expose/:dir/:name', routes.expose);\r\n\r\nDepois disso podemos salvar o `list.jade` na pasta `/views/beers/`.\r\n\r\nE agora corrigimos nossa rota `/beers` no app do AngularJs:\r\n\r\n    when('/beers', {\r\n      templateUrl: 'expose/beers/list',\r\n      controller: 'BeersIndexCtrl'\r\n    }).\r\n\r\nPronto. Agora sempre vamos buscar nossas views utilizando a rota `expose/:dir:name` deixando assim nossa função de partials mais genérica.\r\n\r\n####Consultar\r\nNesse ponto já integramos nossa listagem em MEAN, precisamos agora fazer a consulta individual de cada cerveja, então vamos refatorar nossa view `list`:\r\n\r\n    tr(data-ng-repeat='cerveja in cervejas | orderBy:predicate:reverse')\r\n      td \r\n        a(data-ng-href='/beers/{{cerveja._id}}')\r\n          {{ cerveja.name }}\r\n      td \r\n        a(data-ng-href='/beers/{{cerveja._id}}')\r\n          {{ cerveja.category }}\r\n\r\nDepois de colocarmos um link para cada cerveja no formato `/beers/:id` precisamos criar essa rota no AngularJs:\r\n\r\n    .when('/beers/:id', {\r\n      templateUrl: 'expose/beers/show',\r\n      controller: 'BeersShowCtrl'\r\n    }).\r\n\r\nVamos criar a nossa view `beers/show.jade`:\r\n    \r\n    h3\r\n      | {{ workshop }}\r\n\r\n    ul\r\n      h4 {{ cerveja.name }}\r\n      li\r\n        | Name: {{ cerveja.name }}\r\n      li\r\n        | Category: {{ cerveja.category }}\r\n      li\r\n        | Alcohol: {{ cerveja.alcohol }}\r\n      li\r\n        | Price: {{ cerveja.price }}\r\n      li\r\n        | Description: {{ cerveja.description }}\r\n\r\nDepois disso criar o controller `BeersShowCtrl`:\r\n\r\n    controller('BeersShowCtrl', ['$scope', '$http', '$routeParams', \r\n      function ($scope, $http, $routeParams) {\r\n      $scope.workshop = 'Workshop Be MEAN';\r\n\r\n      // Precisamos buscar nosssa cerveja na nossa API\r\n      var id = $routeParams.id;\r\n      var url = '/api/beers/'+id;\r\n\r\n      $http.get(url)\r\n      .success(function(data){\r\n        $scope.cerveja = data;\r\n        console.log('Cerveja', $scope.cerveja);\r\n      })\r\n      .error(function(err){\r\n        console.log('Error: ', err);\r\n      });\r\n\r\n    }])\r\n\r\nNesse controller usamos o $routeParams do AngularJs para pegar as variáveis da rota, igual o `request.params` do Express.\r\n\r\nE pronto quando clickarmos em qualquer link da nossa listagem das cervejas vamos entrar na rota que irá mostrar os dados da cerveja.\r\n\r\n###CREATE\r\nAntes de criarmos nossas funcionalidades de `UPDATE` e `DELETE` vamos criar a funcionalidade de criação da cerveja, primeiramente criando sua rota no AngularJs:\r\n\r\n    when('/beers/create', {\r\n      templateUrl: 'expose/beers/create',\r\n      controller: 'BeersCreateCtrl'\r\n    }).\r\n\r\nAgora vamos criar nossa view `create.jade`:\r\n    \r\n    h3 {{ workshop }}\r\n    h4 {{ msg }}\r\n    form.container-small\r\n      label\r\n        | Name:\r\n        input(type='text', name='cerveja.name', \r\n              data-ng-model='cerveja.name')\r\n      label\r\n        | Category:\r\n        input(type='text', name='cerveja.category', \r\n              data-ng-model='cerveja.category')\r\n      label\r\n        | Price:\r\n        input(type='text', name='cerveja.price', \r\n              data-ng-model='cerveja.price')\r\n      label\r\n        | Alcohol:\r\n        input(type='text', name='cerveja.alcohol', \r\n              data-ng-model='cerveja.alcohol')\r\n      label\r\n        | Description:\r\n        textarea(name='description', \r\n                data-ng-model='cerveja.description')\r\n      button(data-ng-click='create(cerveja)')\r\n        | Criar\r\n\r\n\r\nLogo precisamos ir no nosso controller `BeersCreateCtrl` e adicionar a função `create`:\r\n\r\n    controller('BeersCreateCtrl', ['$scope', '$http', function ($scope, $http) {\r\n      $scope.workshop = 'Workshop Be MEAN';\r\n      $scope.msg = 'Cadastro de cerveja'\r\n      var url = '/api/beers/';\r\n      $scope.create = function(cerveja){\r\n        var method = 'POST';\r\n        console.table(cerveja);\r\n        $http({\r\n          method: method,\r\n          url: url,\r\n          data: cerveja\r\n        }).\r\n        success(function(data){\r\n          $scope.msg = 'Cerveja ' + cerveja.name + ' criada com SUCESSO';\r\n        }).\r\n        error(function(err){\r\n          console.log('Error: ', err);\r\n          $scope.msg = 'Error:  ' + err;\r\n        });\r\n      }\r\n    }])\r\n\r\nCriei um $scope.msg para dar um feedback da ação para o usuário de forma simples. E pronto após isso podemos ir na nossa rota `beers/create` e criarmos nossa cerveja.\r\n\r\n####$http\r\nNo `$http` agora estamos passando um objeto com as configurações da requisição:\r\n    \r\n    {\r\n      method: method,\r\n      url: url,\r\n      data: cerveja\r\n    }\r\n\r\nOnde:\r\n- method: é o verbo do HTTP que vamos usar\r\n- url: é a url que nossa requisição utilizará\r\n- data: é o objeto a ser enviado pela requisição\r\n\r\n###UPDATE\r\nDepois de listarmos e criarmos nossas cervejas precisamos poder alterá-las também, então dentro da nossa view `show` vamos adicionar um link para o `UPDATE` e para o `DELETE`:\r\n\r\n    p\r\n      a(data-ng-href='beers/{{cerveja._id}}/edit')\r\n        | Alterar\r\n    p \r\n      a(data-ng-href='beers/{{cerveja._id}}/remove')\r\n        | Excluir\r\n\r\nApós adicionarmos esses links precisamos criar suas respectivas rotas:\r\n\r\n    when('/beers/:id/edit', {\r\n      templateUrl: 'expose/beers/edit',\r\n      controller: 'BeersEditCtrl'\r\n    }).\r\n    when('/beers/:id/remove', {\r\n      templateUrl: 'expose/beers/remove',\r\n      controller: 'BeersRemoveCtrl'\r\n    })\r\n\r\nE agora vamos criar seus controllers:\r\n\r\n    controller('BeersEditCtrl', ['$scope', '$http', '$routeParams', \r\n      function ($scope, $http, $routeParams) {\r\n      $scope.workshop = 'Workshop Be MEAN';\r\n\r\n      // Precisamos buscar nosssa cerveja na nossa API\r\n      var id = $routeParams.id;\r\n      var url = '/api/beers/'+id;\r\n\r\n    }]).\r\n    controller('BeersRemoveCtrl', ['$scope', '$http', '$routeParams', \r\n      function ($scope, $http, $routeParams) {\r\n      $scope.workshop = 'Workshop Be MEAN';\r\n\r\n      // Precisamos buscar nosssa cerveja na nossa API\r\n      var id = $routeParams.id;\r\n      var url = '/api/beers/'+id;\r\n\r\n    }])\r\n\r\nVamos iniciar pela criação da view `edit.jade`:\r\n\r\n    h3 {{ workshop }}\r\n    h4 {{ msg }}\r\n    form.container-small\r\n      label\r\n        | Name:\r\n        input(type='text', name='cerveja.name', \r\n              data-ng-model='cerveja.name')\r\n      label\r\n        | Category:\r\n        input(type='text', name='cerveja.category', \r\n              data-ng-model='cerveja.category')\r\n      label\r\n        | Price:\r\n        input(type='text', name='cerveja.price', \r\n              data-ng-model='cerveja.price')\r\n      label\r\n        | Alcohol:\r\n        input(type='text', name='cerveja.alcohol', \r\n              data-ng-model='cerveja.alcohol')\r\n      label\r\n        | Description:\r\n        textarea(name='description', \r\n                data-ng-model='cerveja.description')\r\n      button(data-ng-click='update(cerveja)')\r\n        | Salvar\r\n\r\nAgora vamos no nosso controller `BeersEditCtrl` e criar a função que vai consultar a cerveja a ser alterada, ou seja, re-usar a função onde mostramos os dados da cerveja. Para isso inicialmente adicionamos o `$routeParams`:\r\n\r\n    controller('BeersCreateCtrl', ['$scope', '$http', '$routeParams', \r\n      function ($scope, $http, $routeParams)\r\n\r\nE chamamos a cerveja a ser alterada para mostrar os valores na view:\r\n\r\n    // Precisamos buscar nosssa cerveja na nossa API\r\n    var id = $routeParams.id;\r\n    var url = '/api/beers/'+id;\r\n    var method = 'GET';\r\n    $http({\r\n      method: method,\r\n      url: url\r\n    })\r\n    .success(function(data){\r\n      $scope.msg = 'Cerveja ' + data.name;\r\n      $scope.cerveja = data;\r\n    })\r\n    .error(function(err){\r\n      console.log('Error: ', err);\r\n      $scope.msg = 'Error:  ' + err;\r\n    });\r\n\r\nApós buscarmos nossa cerveja a ser alterada, precisamos criar a função de  `UPDATE`:\r\n\r\n    // Função de alterar\r\n    $scope.update = function(cerveja){    \r\n      method = 'PUT';\r\n      $http({\r\n        method: method,\r\n        url: url,\r\n        data: cerveja\r\n      })\r\n      .success(function(data){\r\n        $scope.msg = 'Cerveja ' + cerveja.name + ' alterada com SUCESSO';\r\n      })\r\n      .error(function(err){\r\n        console.log('Error: ', err);\r\n        $scope.msg = 'Error:  ' + err;\r\n      });\r\n    }\r\n\r\n\r\nDepois da view vamos criar a função `update` no controller `BeersEditCtrl`:\r\n\r\nPorém vamos fazer uma modificação no controller da nossa API `controllers/api/beer.js`:\r\n\r\n\r\n    update: function(req, res){\r\n      // criando o objeto de query\r\n      // para fazer a busca da cerveja a ser alterada\r\n      var query = {_id: req.params.id};\r\n      // crio o objeto de modificação da cerveja\r\n      // recebendo os dados via req.body\r\n      var mod = req.body;\r\n      Beer.update(query, mod, function (err, data) {\r\n        if (err){\r\n          console.log('Erro: ', err);\r\n          // msg = 'Erro ao atualizar a cerveja!';\r\n          msg = 0;\r\n        }else{\r\n          console.log('Cerveja atualizada com sucesso', data);\r\n          // msg = 'Cerveja atualizada com sucesso!';    \r\n          // retorna quantidade de cervejas atualizadas\r\n          msg = data;\r\n        } \r\n        // enviando a msg para o cliente\r\n        res.json(msg);\r\n      });\r\n    }\r\n\r\nMudamos o `res.send` para `res.json` para que nossa requisição do AngularJs não caia no `error`.\r\n\r\n\r\n###DELETE\r\nComo já havíamos criado a rota do `DELETE` vamos agora criar nossa view, que basicamente é a mesma do show apenas com o botão para deletar.\r\n\r\n    h3 {{ workshop }}\r\n    h4 {{ msg }}\r\n\r\n    ul\r\n      h4 {{ cerveja.name }}\r\n      li\r\n        | Name: {{ cerveja.name }}\r\n      li\r\n        | Category: {{ cerveja.category }}\r\n      li\r\n        | Alcohol: {{ cerveja.alcohol }}\r\n      li\r\n        | Price: {{ cerveja.price }}\r\n      li\r\n        | Description: {{ cerveja.description }}\r\n\r\n    p \r\n      button(data-ng-click='remove(cerveja)')\r\n        | Excluir\r\n\r\nDepois alteramos o controller `BeersRemoveCtrl`:\r\n\r\n    controller('BeersRemoveCtrl', ['$scope', '$http', '$routeParams', \r\n      function ($scope, $http, $routeParams) {\r\n      $scope.workshop = 'Workshop Be MEAN';\r\n\r\n      // Precisamos buscar nosssa cerveja na nossa API\r\n      var id = $routeParams.id;\r\n      var url = '/api/beers/'+id;\r\n      var method = 'GET';\r\n      $http({\r\n        method: method,\r\n        url: url\r\n      })\r\n      .success(function(data){\r\n        $scope.msg = 'Cerveja ' + data.name;\r\n        $scope.cerveja = data;\r\n      })\r\n      .error(function(err){\r\n        console.log('Error: ', err);\r\n        $scope.msg = 'Error:  ' + err;\r\n      });\r\n\r\n      // Função de deletar\r\n      $scope.remove = function(cerveja){    \r\n        var method = 'DELETE';\r\n        var query = {\r\n          _id: cerveja._id\r\n        };\r\n\r\n        var http_settings = {\r\n          method: method,\r\n          url: url,\r\n          data: query\r\n        };\r\n        console.log('alterando', http_settings);\r\n        $http(http_settings)\r\n        .success(function(data){\r\n          $scope.msg = 'Cerveja ' + cerveja.name + ' deletada com SUCESSO';\r\n        })\r\n        .error(function(err){\r\n          console.log('Error: ', err);\r\n          $scope.msg = 'Error:  ' + err;\r\n        });\r\n      }\r\n    }])\r\n\r\nLembrando que precisamos editar o `controllers/api/beer.js` na função `delete` para usa o `res.json` em vez do `res.send`:\r\n\r\n    delete: function(req, res){\r\n      // Criando a query para remover a cerveja pelo _id\r\n      var query = {_id: req.params.id};\r\n\r\n      Beer.remove(query, function(err, data) {\r\n        if(err) {\r\n          console.log(err);\r\n          // msg = 'Erro ao deletar a cerveja!';\r\n          msg = 0;\r\n        } else {\r\n          console.log('Cerveja deletada com sucesso', data);\r\n          // msg = 'Cerveja deletada com sucesso!';\r\n          // retorna a quantidade de elementos deletados\r\n          msg = data;\r\n        }\r\n        // enviando a msg para o cliente\r\n        res.json(msg);\r\n      });\r\n    }\r\n\r\n\r\n\r\n\r\n##Projeto Final 29/JUlHO/2014\r\nCriar um sistema que seja composto de lojas de cervejas, onde os usuários poderão se cadastrar e falar que tomaram as cervejas. Nisso teremos basiacamente 3 coleções:\r\n\r\n- users\r\n- shops\r\n- beers\r\n\r\nOnde beers terá um array que conterá o ObjectId de cada cerveja que eles vendam e os usuarios possuirão um array com cada cerveja que já tomaram.\r\n\r\nO sistema deverá ser um Single Page App onde o usuário se cadastrará e pesquisará pelas cervejas, **dica: use regex na query**, a cerveja que ele quiser poderá adicionar em sua coleção. E nessa cerveja além dos seus dados também mostrará quais lojas vendem.\r\n\r\n####Model beer\r\n- name\r\n- price\r\n- alcohol\r\n- category\r\n- description\r\n\r\n####Model shop\r\n- name\r\n- address //object {logradouro, nome, numero, complemento, bairro, cidade, estado, país}\r\n- beers\r\n\r\n####Model user\r\n- login\r\n- email\r\n- password //criptografado\r\n- birth //data de nascimento\r\n- beers\r\n\r\nNa parte de user pode ser usado o Passport ou diretamente o mean.io que já possui um boilerplate usável com o Passport já integrado.\r\n\r\nAlém dos CRUDs a interface também contará pontos e todos os projetos deverão ser enviados via [github](http://github.com).\r\n\r\nPodendo usar boilerplates de css como: Boostrap, Foundation e outros.\r\n\r\n\r\n####Tópicos a serem explicados via Hangouts:\r\n\r\n- Node.js: crypt\r\n- Mongoose: pre save\r\n- Mongoose: populate\r\n- MEAN.io: arquitetura, passport\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}